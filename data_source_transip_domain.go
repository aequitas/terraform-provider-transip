package main

import (
	"fmt"

	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
	"github.com/transip/gotransip/v6/domain"
	"github.com/transip/gotransip/v6/repository"
)

func dataSourceDomain() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceDomainRead,
		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Description: "The name, including the tld of this domain.",
				Required:    true,
			},
			"nameservers": {
				Type:        schema.TypeList,
				Description: "List of nameservers associated with domain.",
				Computed:    true,
				Elem: &schema.Schema{
					Type: schema.TypeMap,
				},
			},
			"tags": {
				Type:        schema.TypeList,
				Description: "The custom tags added to this domain.",
				Computed:    true,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"authcode": {
				Type:        schema.TypeString,
				Description: "The authcode for this domain as generated by the registry.",
				Computed:    true,
			},
			"cancellation_date": {
				Type:        schema.TypeString,
				Description: "Cancellation data, in YYYY-mm-dd h:i:s format, null if the domain is active.",
				Computed:    true,
			},
			"cancellation_status": {
				Type:        schema.TypeString,
				Description: "Cancellation status, null if the domain is active, 'cancelled' when the domain is cancelled.",
				Computed:    true,
			},
			"is_dns_only": {
				Type:        schema.TypeBool,
				Description: "Whether this domain is DNS only.",
				Computed:    true,
			},
			"is_transfer_locked": {
				Type:        schema.TypeBool,
				Description: "If this domain supports transfer locking, this flag is true when the domains ability to transfer is locked at the registry.",
				Computed:    true,
			},
			"is_whitelabel": {
				Type:        schema.TypeBool,
				Description: "If this domain is added to your whitelabel.",
				Computed:    true,
			},
			"registration_date": {
				Type:        schema.TypeString,
				Description: "Registration date of the domain, in YYYY-mm-dd format.",
				Computed:    true,
			},
			"renewal_date": {
				Type:        schema.TypeString,
				Description: "Next renewal date of the domain, in YYYY-mm-dd format.",
				Computed:    true,
			},
		},
	}
}

func dataSourceDomainRead(d *schema.ResourceData, m interface{}) error {
	name := d.Get("name").(string)

	client := m.(repository.Client)
	repository := domain.Repository{Client: client}
	i, err := repository.GetByDomainName(name)
	if err != nil {
		return fmt.Errorf("failed to lookup domain %q: %s", name, err)
	}

	var nameservers []map[string]string
	ns, err := repository.GetNameservers(name)
	if err != nil {
		return fmt.Errorf("failed to lookup nameservers for domain %q: %s", name, err)
	}

	for _, n := range ns {
		nameservers = append(nameservers, map[string]string{
			"hostname":     n.Hostname,
			"ipv4_address": n.IPv4.String(),
			"ipv6_address": n.IPv6.String(),
		})
	}

	d.SetId(i.Name)
	d.Set("nameservers", nameservers)
	d.Set("tags", i.Tags)
	d.Set("authcode", i.AuthCode)
	d.Set("cancellation_date", i.CancellationDate)
	d.Set("cancellation_status", i.CancellationStatus)
	d.Set("is_dns_only", i.IsDNSOnly)
	d.Set("is_transfer_locked", i.IsTransferLocked)
	d.Set("is_whitelabel", i.IsWhitelabel)
	d.Set("registation_date", i.RegistrationDate)
	d.Set("renewal_date", i.RenewalDate)

	return nil
}
